@app.get("/settings/notifications")
def get_notification_settings():
    """Retrieve current notification settings."""
    try:
        session = SessionLocal()
        settings = session.query(NotificationSettings).first()
        session.close()
        
        if not settings:
            return {
                "status": "success",
                "data": {
                    "id": None,
                    "critical_alert_emails_enabled": True,
                    "high_priority_notifications_enabled": True,
                    "alert_email_address": None,
                    "daily_summary_report_enabled": False,
                    "slack_webhook_url": None,
                    "sms_phone_number": None,
                    "risk_score_threshold_for_critical": 0.80,
                    "risk_score_threshold_for_high": 0.70,
                }
            }
        
        return {
            "status": "success",
            "data": {
                "id": settings.id,
                "critical_alert_emails_enabled": bool(settings.critical_alert_emails_enabled),
                "high_priority_notifications_enabled": bool(settings.high_priority_notifications_enabled),
                "alert_email_address": settings.alert_email_address,
                "daily_summary_report_enabled": bool(settings.daily_summary_report_enabled),
                "slack_webhook_url": settings.slack_webhook_url,
                "sms_phone_number": settings.sms_phone_number,
                "risk_score_threshold_for_critical": settings.risk_score_threshold_for_critical,
                "risk_score_threshold_for_high": settings.risk_score_threshold_for_high,
                "created_at": settings.created_at.isoformat() if settings.created_at else None,
                "updated_at": settings.updated_at.isoformat() if settings.updated_at else None,
            }
        }
    except Exception as e:
        send_log(logger, "ERROR", f"Failed to get notification settings: {e}")
        raise HTTPException(500, str(e))


@app.post("/settings/notifications")
def update_notification_settings(req: NotificationSettingsRequest):
    """Update notification settings."""
    try:
        session = SessionLocal()
        settings = session.query(NotificationSettings).first()
        
        if not settings:
            settings = NotificationSettings()
            session.add(settings)
        
        # Update only provided fields
        if req.critical_alert_emails_enabled is not None:
            settings.critical_alert_emails_enabled = int(req.critical_alert_emails_enabled)
        
        if req.high_priority_notifications_enabled is not None:
            settings.high_priority_notifications_enabled = int(req.high_priority_notifications_enabled)
        
        if req.alert_email_address is not None:
            settings.alert_email_address = req.alert_email_address
        
        if req.daily_summary_report_enabled is not None:
            settings.daily_summary_report_enabled = int(req.daily_summary_report_enabled)
        
        if req.slack_webhook_url is not None:
            settings.slack_webhook_url = req.slack_webhook_url
        
        if req.sms_phone_number is not None:
            settings.sms_phone_number = req.sms_phone_number
        
        if req.risk_score_threshold_for_critical is not None:
            settings.risk_score_threshold_for_critical = req.risk_score_threshold_for_critical
        
        if req.risk_score_threshold_for_high is not None:
            settings.risk_score_threshold_for_high = req.risk_score_threshold_for_high
        
        session.commit()
        send_log(logger, "INFO", "Notification settings updated")
        
        return {
            "status": "success",
            "message": "Notification settings updated successfully",
            "data": {
                "id": settings.id,
                "critical_alert_emails_enabled": bool(settings.critical_alert_emails_enabled),
                "high_priority_notifications_enabled": bool(settings.high_priority_notifications_enabled),
                "alert_email_address": settings.alert_email_address,
                "daily_summary_report_enabled": bool(settings.daily_summary_report_enabled),
                "slack_webhook_url": settings.slack_webhook_url,
                "sms_phone_number": settings.sms_phone_number,
                "risk_score_threshold_for_critical": settings.risk_score_threshold_for_critical,
                "risk_score_threshold_for_high": settings.risk_score_threshold_for_high,
                "updated_at": settings.updated_at.isoformat() if settings.updated_at else None,
            }
        }
    except Exception as e:
        send_log(logger, "ERROR", f"Failed to update notification settings: {e}")
        raise HTTPException(500, str(e))
    finally:
        session.close()


@app.get("/settings/detection")
def get_detection_settings():
    """Retrieve current detection settings."""
    try:
        session = SessionLocal()
        settings = session.query(DetectionSettings).first()
        session.close()
        
        if not settings:
            return {
                "status": "success",
                "data": {
                    "id": None,
                    "risk_score_threshold": 70.0,
                    "duplicate_detection_window_hours": 24,
                    "ai_enhanced_detection_enabled": True,
                }
            }
        
        return {
            "status": "success",
            "data": {
                "id": settings.id,
                "risk_score_threshold": settings.risk_score_threshold,
                "duplicate_detection_window_hours": settings.duplicate_detection_window_hours,
                "ai_enhanced_detection_enabled": bool(settings.ai_enhanced_detection_enabled),
                "created_at": settings.created_at.isoformat() if settings.created_at else None,
                "updated_at": settings.updated_at.isoformat() if settings.updated_at else None,
            }
        }
    except Exception as e:
        send_log(logger, "ERROR", f"Failed to get detection settings: {e}")
        raise HTTPException(500, str(e))


@app.post("/settings/detection")
def update_detection_settings(req: DetectionSettingsRequest):
    """Update detection settings."""
    try:
        session = SessionLocal()
        settings = session.query(DetectionSettings).first()
        
        if not settings:
            settings = DetectionSettings()
            session.add(settings)
        
        # Update only provided fields
        if req.risk_score_threshold is not None:
            # Validate range 0-100
            if not (0 <= req.risk_score_threshold <= 100):
                raise ValueError("Risk score threshold must be between 0 and 100")
            settings.risk_score_threshold = req.risk_score_threshold
        
        if req.duplicate_detection_window_hours is not None:
            if req.duplicate_detection_window_hours < 1:
                raise ValueError("Duplicate detection window must be at least 1 hour")
            settings.duplicate_detection_window_hours = req.duplicate_detection_window_hours
        
        if req.ai_enhanced_detection_enabled is not None:
            settings.ai_enhanced_detection_enabled = int(req.ai_enhanced_detection_enabled)
        
        session.commit()
        send_log(logger, "INFO", "Detection settings updated")
        
        return {
            "status": "success",
            "message": "Detection settings updated successfully",
            "data": {
                "id": settings.id,
                "risk_score_threshold": settings.risk_score_threshold,
                "duplicate_detection_window_hours": settings.duplicate_detection_window_hours,
                "ai_enhanced_detection_enabled": bool(settings.ai_enhanced_detection_enabled),
                "updated_at": settings.updated_at.isoformat() if settings.updated_at else None,
            }
        }
    except ValueError as e:
        send_log(logger, "ERROR", f"Invalid detection settings: {e}")
        raise HTTPException(400, str(e))
    except Exception as e:
        send_log(logger, "ERROR", f"Failed to update detection settings: {e}")
        raise HTTPException(500, str(e))
    finally:
        session.close()


@app.get("/settings/data-integration")
def get_data_integration_status():
    """Check database and data stream connection status."""
    try:
        session = SessionLocal()
        integration_settings = session.query(DataIntegrationSettings).first()
        
        # Check database connection
        db_status = "DISCONNECTED"
        try:
            with engine.connect() as conn:
                conn.execute(text("SELECT 1"))
            db_status = "CONNECTED"
        except Exception as e:
            send_log(logger, "WARN", f"Database connection check failed: {e}")
            db_status = "DISCONNECTED"
        
        # Update or create integration settings
        if not integration_settings:
            integration_settings = DataIntegrationSettings()
            session.add(integration_settings)
        
        integration_settings.database_connection_status = db_status
        integration_settings.database_last_check = datetime.now(timezone.utc)
        session.commit()
        
        # Data stream status is checked by seeing if data is flowing (from ingestion module)
        data_stream_status = integration_settings.data_stream_status or "UNKNOWN"
        
        response_data = {
            "status": "success",
            "data": {
                "database_connection": {
                    "name": "PostgreSQL primary database",
                    "status": db_status,
                    "last_check": integration_settings.database_last_check.isoformat() if integration_settings.database_last_check else None,
                },
                "data_stream": {
                    "name": "Real-time transaction feed",
                    "status": data_stream_status,
                    "last_check": integration_settings.data_stream_last_check.isoformat() if integration_settings.data_stream_last_check else None,
                },
                "external_api": {
                    "name": "Third-party verification",
                    "status": integration_settings.external_api_status or "UNKNOWN",
                    "url": integration_settings.external_api_url,
                    "last_check": integration_settings.external_api_last_check.isoformat() if integration_settings.external_api_last_check else None,
                }
            }
        }
        
        session.close()
        return response_data
    
    except Exception as e:
        send_log(logger, "ERROR", f"Failed to get data integration status: {e}")
        raise HTTPException(500, str(e))


@app.post("/settings/data-integration")
def update_data_integration_settings(req: DataIntegrationSettingsRequest):
    """Update data integration settings."""
    try:
        session = SessionLocal()
        settings = session.query(DataIntegrationSettings).first()
        
        if not settings:
            settings = DataIntegrationSettings()
            session.add(settings)
        
        # Update external API URL if provided
        if req.external_api_url is not None:
            settings.external_api_url = req.external_api_url
            send_log(logger, "INFO", f"Updated external API URL: {req.external_api_url}")
        
        session.commit()
        
        return {
            "status": "success",
            "message": "Data integration settings updated",
            "data": {
                "external_api_url": settings.external_api_url,
                "updated_at": settings.updated_at.isoformat() if settings.updated_at else None,
            }
        }
    
    except Exception as e:
        send_log(logger, "ERROR", f"Failed to update data integration settings: {e}")
        raise HTTPException(500, str(e))
    finally:
        session.close()